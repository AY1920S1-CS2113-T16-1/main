= Le Duc - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets


---

== Target User
* *Target*: Super busy student who has "multiple life".
* *Problem Scope*: Organize a students school tasks and non-academic tasks.
* *Value Proposition*: A student will be able to better manage their time, and be more productive.

---

== User Stories

[cols="3,5,1", options="header"]
|===
|Target |User Stories |Priority

|As a student,| I want to sort my task by type of task/by date/by description/by tag
|* * *

|As a student,| I want to prioritize different task
|* * *

|As a student,| I want to have recurrent task
|* * *

|As a student,| I want to display the task by day/week/month/year
|* * *

|As a student,| I want to edit a task
|* * *

|As a student,| I want to a better find feature (fuzzy matching)
|* * *

|As a student,| I want to postpone a task
|* * *

|As a student,| I want to have shortcut
|* * *

|As a student,| I want to display two or more different task list (for example professional and personal)
|* * *

|As a student,| I want the app to send me an email about my task
|* *

|As a student,| I want to display only the task that hasn't been done yet
|* *

|As a student,| I want the app to alarm me when a deadline is near
|* *

|As a student,| I want to import from other task list
|* *

|As a student,| I want to have subtask
|* *

|As a student,| I want to see which task was done late, which task hadn't been done and which task was done on time
|* *

|As a student,| I want to set a reminder
|* *

|As a student,| I want to see my progression
|* *

|As a student,| I want to add an excepted time
|* *

|As a student,| I want to see the time left until the allocated time for that task is over
|* *

|As a student,| I want to know the location, the address
|* *

|As a student,| I want to combine two tasks
|* *

|As a student,| I want to visualize the task (GUI)
|*

|As a student,| I want to have a login and a password or have a profile
|*

|As a student,| I want to customize the welcome message
|*

|As a student,| I want to have secret task
|*

|As a student,| I want to have shared task
|*

|As a student,| I want to delete a profile (like an admin)
|*

|As a student,| I want to have some statistics
|*

|As a student,| I want to see others students task
|*

|As a student,| I want to have a message feature
|*
|===

---

== Use Cases


* *Edit Command*: ( only in multi-step commands yet)
** *System*: Le Duc
** *Actor*: High school student
** *Use Case*: Modify task
*** User will type “edit”
*** Le Duc will list the entire task list
*** User type the index of the task
*** Le Duc asks which part will be modified if it is not a Todo task
*** User answer and modify

* *Shortcut*:
** *System*: Le Duc
** *Actor*: High school student
** *Use Case*: Create shortcut
*** User type “shortcut”
*** Le Duc will show the first command to be modified
*** User type the shortcut for that command
*** Le Duc will show the second command to be modified
*** User type the shortcut for that command
*** ...
*** Le Duc will show the k command to be modified
*** User type the shortcut for that command
*** Le Duc prompt an error, because there is a conflict between two shortcuts, and will ask to enter a new shortcut
*** User type another shortcut for that command
*** ...
*** Le Duc shows all the shortcuts

---




---
== Non-functional requirements

* *Task list size requirement*: The user is a super busy students, so he will have a lot of task. Size of task list possibly infinite (use of Arraylist, depends on the computer and the storage doesn’t use much as it is a written file).
* *Quality requirement*: The system is easy to understand and to be handled by a new user.
* *Mastery requirement*: The system is easy to be mastered, the typing of new task should be easy and fast.
* *Disaster recovery requirement*: If the system crash, the user shall find all his tasks in the storage file.



---

== Glossary

* *Fuzzy matching*: When searching for task descriptions via keyword, the "Sorensen-Dice" Fuzzy Matching algorithm is used to return top matches. This ensures that typos in the user query does not affect search performance
* *Recurrent task*: A task that repeat every day/week/month…

---

== Implementation

=== Shortcut


The shortcut mechanism is done by the ShortcutCommand. As every other command, it extends Command with a HashSet containing all the command’s shortcut name and another HashSet containing all the default command’s shortcut name. Others commands include now a static attribute named shortcut that correspond to the command’s shortcut. It implements these following methods:

* `ShortcutCommand#setOneShortcut` — set the shortcut of one command
* `ShortcutCommand#initializedSetShortcut` — initialized the HashSet contains all the default command’s shortcut name

There are three cases:

* one shot one command: The user write the command for the shortcut in one line
* multi step one command: The user write which command he wants to add a shortcut to, then the console ask what is the shortcut, and the user write the name of the shortcut
* multi step every command: The user asks the console that he wants to modify all the command, and the console will show one by one every command, and the user will modify one by one each command.

When the user launches the application, the program will read the config file, then set all shortcuts to previous shortcuts that the user has decided. If the user has not decided to customized shortcuts, it will be the default shortcut.

These following diagram show how the 3 cases were implemented:

==== One shot one command

The user type the "entry" (not shown in the sequence diagram) as `shortcut CommandName ShortcutName`.

image::SDShortcutOneShot.png[width="790"]

The method setShortcut is static, thus an object Command won’t be created

==== Multi-step one command

The user type the "entry" (not shown in the sequence diagram) as `shortcut CommandName`. Then the console will ask what will be the new name for the shortcut.

image::SGShortcutMultiOneCmd.png[width="790"]

==== Multi-step every command

The user type the "entry" (not shown in the sequence diagram) as `shortcut`. The console will display one command's name, then the console will ask what will be the new name for the shortcut. The console will repeat until every command have a shortcut.

image::SGShortcutMultiEveryCmd.png[width="790"]

==== Consideration
* The config file that contains all the name for the shortcut can be edit by hand, because it is faster to edit the config file than doing it via the application.
* When a command’s shortcut is set, the default shortcut can still be used


=== Modify a Task

Several commands allow the user to modify a task: `reschedule`, `postpone`, `snooze` and `edit` .
As every other command, these commands extend Command.
As these commands relate to the modification of tasks, each command need to write into the data file after its execution.

* *Reschedule an event task*

When rescheduling an event, two dates can’t clash. This verification is done with the verifyConflictDate method which is
in the TaskList class. Indeed, all task dates are needed to verify if there is a conflict. So, this allows to improve the cohesion.

image::SequenceDiagramReschedule.png[width="1000", align="left"]

* *Snooze an homework task*

Snooze is applicable to a homework task. The snooze time is fixed at 30 minutes( it could be easily changed in the snoozeLocalDateTime() method of Date.

image::SequenceDiagramSnooze.png[width="1000", align="left"]

* *Postpone an homework task*

Postpone is also only applicable to a homework task. The new date should be after the old one.
This is verified inside the execution of the postponeCommand.

image::SequenceDiagramPostpone.png[width="1000", align="left"]

* *Edit a task* ( Only in multi-set commands yet)


=== Remind


The Remind feature is done by the RemindCommand. Along with all of the other implemented commands, it extends Command. The feature will process each tasks date/timestamps to order them, and then remind the user of the top 3 upcoming tasks. The following methods were implemented in this feature:

* `filterTasks` - Extracts the Homework and Event tasks into a seperate ArrayList
* `sort` - Orders the filtered TaskList in chronological order.

* *Sequence Diagram of the Remind Feature:*

image::RemindSequenceDiagram.png[width="790"]
There are 3 cases:

* TaskList contains a mix of all objects
* TaskList contains only Todo objects
* TaskList contains no objects

All cases are handled separately, as the tasks must be ordered differently.

==== TaskList contains only homework/Event objects

* The original TaskList is passed through a filter.
* The filtered TaskList is equal to the original TaskList, as there are no Todo objects to filter out. The filtered TaskList will then be sorted by TakList.sort(). The method will call each tasks .getDate() and build a sorted ArrayList. All Todo's will be appended to the end of the sortedlist
* The first 3 most upcoming tasks will be displayed to the user.
* *Output:*

```---------------------------------------------------------------------------------
remind
1. [D][✗] d1 by: 14/09/2019 22:33 [Priority: 5]
2. [E][✗] e1 at: 21/09/2019 00:00 - 28/10/2019 22:22 [Priority: 5]
3. [T][✗] td1 [Priority: 5]
```
==== TaskList only contains Todo Objects

* The TaskList.sort() method will return the original list containing only Todo's. Todo tasks have no associated date, so the order in which they were created will be preserved. This is assuming that the order they were created by the user is the order of the intended completion.
* *Output:*
```---------------------------------------------------------------------------------
remind
1. [T][✗] todo1 [Priority: 5]
2. [T][✗] todo2 [Priority: 5]
3. [T][✗] todo3 [Priority: 5]
```
==== TaskList Contains No Objects

```
---------------------------------------------------------------------------------
    There are no upcoming tasks in your list
---------------------------------------------------------------------------------

```

==== Consideration
* Sorting the TaskList in place was considered, but it reduced cohesion of the design.
* It was considered to only remind the user of tasks that are coming up in the next week,
but that would limit its potential utility


---